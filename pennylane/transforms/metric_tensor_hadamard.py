# Copyright 2018-2021 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Contains the transform to compute the full metric tensor using Hadamard tests
and an auxiliary qubit.
"""
import functools
import numpy as np
import pennylane as qml

from .metric_tensor_cov_matrix import metric_tensor_cov_matrix

_GEN_TO_CGEN = {
    qml.PauliX: qml.CNOT,
    qml.PauliY: qml.CY,
    qml.PauliZ: qml.CZ,
}

_OP_TO_CGEN = {
    # PhaseShift is the same as RZ up to a global phase
    qml.PhaseShift: qml.CZ,
}


@functools.lru_cache
def _get_gen_op(op, allow_nonunitary, aux_wire):
    """Get the controlled-generator operation for a given operation.

    Args:
        op (pennylane.operation.Operation): Operation from which to extract the generator
        allow_nonunitary (bool): Whether non-unitary gates are allowed in the circuit
        aux_wire (int or pennylane.wires.Wires): Auxiliary wire on which to control the operation

    Returns
        qml.Operation: Controlled-generator operation of the generator of ``op``, controlled
        on wire ``aux_wire``.

    Raises
        ValueError: If the generator of ``op`` is not known or it is non-unitary while
        ``allow_nonunitary=False``.

    If ``allow_nonunitary=True``, a general :class:`~.pennylane.ControlledQubitUnitary` is returned,
    otherwise only controlled Pauli operations are used. If the operation has a non-unitary
    generator but ``allow_nonunitary=False``, the operation ``op`` should have been decomposed
    before, leading to a ``ValueError``.
    """
    gen, _ = op.generator
    try:
        if isinstance(gen, np.ndarray) or gen not in _GEN_TO_CGEN:
            cgen = _OP_TO_CGEN[op.__class__]
        else:
            cgen = _GEN_TO_CGEN.get(gen, None)
        return cgen(wires=[aux_wire, *op.wires])

    except KeyError as e:
        if allow_nonunitary:
            if issubclass(gen, qml.operation.Observable):
                gen = gen.matrix
            return qml.ControlledQubitUnitary(gen, control_wires=aux_wire, wires=op.wires)
        raise ValueError(
            f"Generator for operation {op.__name__} not known and non-unitary operations "
            "deactivated via allow_nonunitary=False."
        ) from e


def _get_first_term_tapes(tape, layer_i, layer_j, allow_nonunitary, aux_wire):
    """Obtain the tapes for the first term of all tensor entries
    belonging to an off-diagonal block.

    Args:
        tape (pennylane.tape.QuantumTape): Tape that is being transformed
        layer_i (list): The first layer of parametrized ops, of the format of
            the layers generated by ``iterate_parametrized_layers``
        layer_j (list): The second layer of parametrized ops
        allow_nonunitary (bool): Whether non-unitary operations are allowed
            in the circuit; passed to ``_get_gen_op``
        aux_wire (int or pennylane.wires.Wires): Auxiliary wire on which to
            control the controlled-generator operations

    Returns:
        list[pennylane.tape.QuantumTape]: Transformed tapes that compute the
            first term of the metric tensor for the off-diagonal block belonging
            to the input layers
        list[tuple[int]]: 2-tuple indices assigning the tapes to metric tensor
            entries
    """

    tapes = []
    ids = []
    # Exclude the backwards cone of layer_i from the backwards cone of layer_j
    ops_between_cgens = [op for op in layer_j[0] if op not in layer_i[0]]
    # Iterate over differentiated operation in first layer
    for diffed_op_i, par_idx_i in zip(*layer_i[1:3]):
        gen_op_i = _get_gen_op(diffed_op_i, aux_wire, allow_nonunitary)
        # Iterate over differentiated operation in second layer
        # There will be one tape per pair of differentiated operations
        for diffed_op_j, par_idx_j in zip(*layer_j[1:3]):
            gen_op_j = _get_gen_op(diffed_op_j, aux_wire, allow_nonunitary)
            with tape.__class__() as new_tape:
                # Initialize auxiliary wire
                qml.Hadamard(wires=aux_wire)
                # Apply backward cone of first layer
                for op in layer_i[0]:
                    qml.apply(op)
                # Controlled-generator operation of first diff'ed op
                qml.apply(gen_op_i)
                # Apply first layer and operations between layers
                for op in ops_between_cgens:
                    qml.apply(op)
                # Controlled-generator operation of first diff'ed op
                qml.apply(gen_op_j)
                # Measure auxiliary wire
                qml.expval(qml.PauliX(aux_wire))
            tapes.append(new_tape)
            # Memorize to which metric entry this tape belongs
            ids.append((par_idx_i, par_idx_j))

    return tapes, ids


def metric_tensor_hadamard(tape, allow_nonunitary, aux_wire=None):
    r"""Generate the quantum tapes that execute the Hadamard tests
    to compute the first term of block off-diagonal metric entries
    and combine them with the covariance matrix-based block diagonal tapes.

    Args:
        tape (pennylane.tape.QuantumTape): Tape that is being transformed
        allow_nonunitary (bool): Whether non-unitary operations are allowed
            in the circuit; passed to ``_get_gen_op``
        aux_wire (int or pennylane.wires.Wires): Auxiliary wire on which to
            control the controlled-generator operations. Defaults to
            ``tape.num_wires`` if not provided

    Returns:
        list[pennylane.tape.QuantumTape]: Tapes to evaluate the metric tensor
        callable: processing function to obtain the metric tensor from the tape results

    .. warning::

        This method requires the device used to execute the returned tapes to
        have an additional wire. This wire may be specified via ``aux_wire``.
        By default contiguous numbering and an additional wire at the end
        of the input tape wires are assumed.

    This method is based on computing the first term of the metric tensor with Hadamard
    tests.
    This term reads

    .. math ::

        \mathfrak{Re}\left\{\langle \partial_i\psi|\partial_j\psi\rangle\right\}

    and can be computed using an augmented circuit with an additional qubit.
    See for example `the appendix of this paper <https://arxiv.org/pdf/1804.03023.pdf>`__
    for details.
    The block diagonal of the tensor is computed using the covariance matrix approach
    implemented in :func:`.metric_tensor_cov_matrix`. In addition, we may extract the
    factors for the second terms :math:`\langle \psi|\partial_j\psi\rangle`
    of the block off-diagonal tensor from the tape results for the covariance matrix.
    This means that in total only the tapes for the first terms of the block off-diagonal
    are required in addition to ``metric_tensor_cov_matrix``.
    """
    # Prepare aux_wire
    aux_wire = aux_wire or tape.num_wires
    # Get tapes and processing function for the block diagonal metric tensor,
    # as well as the generator observables and generator coefficients for each diff'ed operation
    diag_tapes, diag_proc_fn, obs_list, coeffs = metric_tensor_cov_matrix(tape, diag_approx=False)
    graph = tape.graph
    layers = list(graph.iterate_parametrized_layers())

    first_term_tapes = []
    ids = []
    block_sizes = []
    # Get all tapes for the first term of the metric tensor
    for idx_i, layer_i in enumerate(layers):
        block_sizes.append(len(layer_i[2]))
        for layer_j in layers[idx_i + 1 :]:
            _tapes, _ids = _get_first_term_tapes(tape, layer_i, layer_j, allow_nonunitary)
            first_term_tapes.extend(_tapes)
            ids.extend(_ids)

    # Combine block diagonal and off-diagonal tapes
    tapes = diag_tapes + first_term_tapes
    # prepare block off-diagonal mask
    mask = 1 - qml.math.block_diag([np.ones((bsize, bsize)) for bsize in block_sizes])
    # Required for slicing in processing_fn
    num_diag_tapes = len(diag_tapes)

    def processing_fn(results):
        diag_res, off_diag_res = results[:num_diag_tapes], results[num_diag_tapes:]
        # Get full block diagonal tensor
        diag_mt = diag_proc_fn(diag_res)
        # Initialize block off-diagonal tensor using the stored ids
        first_term = qml.math.zeros_like(diag_mt)
        for result, idx in zip(off_diag_res, ids):
            # The metric tensor is symmetric
            first_term[idx] = first_term[idx[::-1]] = result

        # Second terms of block off-diagonal metric tensor
        expvals = []
        for prob, obs in zip(diag_res, obs_list):
            for o in obs:
                l = qml.math.cast(o.eigvals, dtype=np.float64)
                w = tape.wires.indices(o.wires)
                p = qml.math.marginal_prob(prob, w)
                expvals.append(qml.math.dot(l, p))

        # Construct <\partial_i\psi|\psi><\psi|\partial_j\psi> and mask it
        second_term = np.outer(expvals, expvals)
        second_term = qml.math.convert_like(second_term, results[0])
        second_term = qml.math.cast_like(second_term, results[0]) * mask
        # Subtract second term from first term
        off_diag_mt = first_term - second_term

        # Rescale first and second term
        _coeffs = np.hstack(coeffs)
        scale = qml.math.convert_like(np.outer(_coeffs, _coeffs), results[0])
        scale = qml.math.cast_like(scale, results[0])
        off_diag_mt = scale * off_diag_mt

        # Combine block diagonal and off-diagonal
        mt = off_diag_mt + diag_mt

        return mt

    return tapes, processing_fn
